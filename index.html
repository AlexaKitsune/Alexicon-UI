<!doctype html>
<html lang="es">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Visor 3D con Three.js — CDN + Import Map</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
        }

        body {
            background: #0b1020;
            color: #cfd6e4;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
        }

        #app {
            position: fixed;
            inset: 0;
            display: grid;
            grid-template-rows: auto 1fr;
        }

        header {
            display: flex;
            align-items: center;
            gap: .75rem;
            padding: .6rem 1rem;
            background: rgba(255, 255, 255, 0.04);
            backdrop-filter: blur(6px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        header .badge {
            font-size: .825rem;
            opacity: .8;
        }

        header .file {
            margin-left: auto;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #progress {
            position: absolute;
            left: 50%;
            top: 52px;
            transform: translateX(-50%);
            width: min(440px, 86vw);
            height: 6px;
            background: rgba(255, 255, 255, .08);
            border-radius: 999px;
            overflow: hidden;
            box-shadow: 0 0 0 1px rgba(255, 255, 255, .06) inset;
        }

        #bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #61dafb, #a5b4fc, #34d399);
            transition: width .2s ease;
        }

        #hint {
            position: absolute;
            left: 1rem;
            bottom: 1rem;
            opacity: .8;
            font-size: .9rem;
            background: rgba(255, 255, 255, 0.04);
            padding: .5rem .75rem;
            border-radius: .6rem;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        #toolbar {
            position: absolute;
            right: 1rem;
            bottom: 1rem;
            display: flex;
            gap: .5rem;
        }

        #toolbar button {
            background: rgba(255, 255, 255, 0.08);
            color: #cfd6e4;
            border: 1px solid rgba(255, 255, 255, 0.12);
            padding: .4rem .6rem;
            border-radius: .6rem;
            cursor: pointer;
        }

        #toolbar button:hover {
            background: rgba(255, 255, 255, 0.14);
        }
    </style>

    <!-- Import Map: resuelve 'three' y sus addons en el navegador -->
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>
    <div id="app">
        <canvas id="webgl"></canvas>
        <button id="reset">Reset cámara</button>
    </div>

    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";
        import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
        import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
        import { FBXLoader } from "three/addons/loaders/FBXLoader.js";
        import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
        import { STLLoader } from "three/addons/loaders/STLLoader.js";

        // --- Render básico ---
        const canvas = document.getElementById('webgl');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.setSize(innerWidth, innerHeight - 52); // resta altura del header
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color('#0b1020');

        const camera = new THREE.PerspectiveCamera(60, innerWidth / (innerHeight - 52), 0.01, 1000);
        camera.position.set(2.5, 1.5, 3.5);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 0.8, 0);

        // Entorno/luces
        const pmrem = new THREE.PMREMGenerator(renderer);
        scene.environment = pmrem.fromScene(new RoomEnvironment(renderer), 0.03).texture;

        const key = new THREE.DirectionalLight(0xffffff, 2.0); key.position.set(5, 5, 5); scene.add(key);
        const fill = new THREE.DirectionalLight(0xffffff, 0.6); fill.position.set(-5, 2, -3); scene.add(fill);
        const rim = new THREE.DirectionalLight(0xffffff, 0.8); rim.position.set(0, 8, -6); scene.add(rim);

        const grid = new THREE.GridHelper(20, 20, 0x44506b, 0x1f2937);
        grid.material.opacity = 0.25; grid.material.transparent = true; scene.add(grid);

        // Progreso
        const bar = document.getElementById('bar');
        function setProgress(x) { bar.style.width = `${Math.round(x * 100)}%`; }

        // Auto-encuadre
        function frameObject(object3D, padding = 1.2) {
            const box = new THREE.Box3().setFromObject(object3D);
            if (!box.isEmpty()) {
                const size = new THREE.Vector3();
                const center = new THREE.Vector3();
                box.getSize(size); box.getCenter(center);
                const radius = Math.max(size.x, size.y, size.z) * 0.5;
                const fov = THREE.MathUtils.degToRad(camera.fov);
                const dist = (radius * padding) / Math.sin(fov / 2);
                const dir = new THREE.Vector3(1, 0.6, 1).normalize();
                camera.position.copy(center.clone().add(dir.multiplyScalar(dist)));
                camera.near = Math.max(0.01, dist / 100);
                camera.far = dist * 10; camera.updateProjectionMatrix();
                controls.target.copy(center); controls.update();
            }
        }

        // Carga de modelos
        async function loadModelFromUrl(url, opts = {}) {
            const { name = "", mime = "" } = opts;

            // Detección robusta de extensión (soporta blob: URLs)
            function detectExt() {
                if (name && name.includes('.')) return name.split('.').pop().toLowerCase();
                if (mime.includes('gltf')) return 'gltf';
                if (mime.includes('glb')) return 'glb';
                if (mime.includes('fbx')) return 'fbx';
                if (mime.includes('obj')) return 'obj';
                if (mime.includes('stl')) return 'stl';
                try {
                    const u = new URL(url);
                    const m = /name=([^&]+)/.exec(u.hash || '');
                    if (m) return decodeURIComponent(m[1]).split('.').pop().toLowerCase();
                } catch { }
                const base = url.split('?')[0].split('#')[0];
                return base.includes('.') ? base.split('.').pop().toLowerCase() : '';
            }

            let ext = detectExt();
            setProgress(0.02);

            let object;

            async function loadAsGLTF() {
                const gltfLoader = new GLTFLoader();
                const draco = new DRACOLoader();
                draco.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/');
                gltfLoader.setDRACOLoader(draco);
                return await new Promise((resolve, reject) => {
                    gltfLoader.load(
                        url,
                        (gltf) => resolve(gltf.scene || gltf.scenes?.[0]),
                        (e) => { if (e.total) setProgress(e.loaded / e.total); },
                        (err) => reject(err)
                    );
                });
            }

            try {
                if (ext === 'gltf' || ext === 'glb' || ext === 'vrm' || url.startsWith('blob:')) {
                    object = await loadAsGLTF();
                } else if (ext === 'fbx') {
                    const loader = new FBXLoader();
                    object = await new Promise((resolve, reject) => {
                        loader.load(url, resolve, (e) => { if (e.total) setProgress(e.loaded / e.total); }, reject);
                    });
                } else if (ext === 'obj') {
                    const loader = new OBJLoader();
                    object = await new Promise((resolve, reject) => {
                        loader.load(url, resolve, (e) => { if (e.total) setProgress(e.loaded / e.total); }, reject);
                    });
                } else if (ext === 'stl') {
                    const loader = new STLLoader();
                    const geom = await new Promise((resolve, reject) => {
                        loader.load(url, resolve, (e) => { if (e.total) setProgress(e.loaded / e.total); }, reject);
                    });
                    const mat = new THREE.MeshPhysicalMaterial({ color: 0x9ab, metalness: 0.1, roughness: 0.5 });
                    object = new THREE.Mesh(geom, mat);
                } else {
                    // Extensión desconocida: intentamos GLTF por defecto (útil para blob: URLs)
                    object = await loadAsGLTF();
                }
            } catch (e) {
                throw new Error('No se pudo cargar el archivo. Si es .gltf con recursos externos (.bin/texturas), conviértelo a .glb o sirve la carpeta completa. Detalle: ' + e.message);
            }

            // Reemplaza modelo anterior
            const old = scene.getObjectByName('__MODEL__');
            if (old) scene.remove(old);
            object.name = '__MODEL__';
            scene.add(object);
            frameObject(object);
            setProgress(1); setTimeout(() => setProgress(0), 600);
        }

        // File input
        const fileInput = document.getElementById('file');
        fileInput.addEventListener('change', (ev) => {
            const file = ev.target.files?.[0];
            if (!file) return;
            let url = URL.createObjectURL(file);
            // Adjunta el nombre real para que el loader pueda inferir extensión
            url += `#name=${encodeURIComponent(file.name)}`;
            loadModelFromUrl(url, { name: file.name, mime: file.type }).catch((e) => alert('Error cargando modelo: ' + e.message));
        });

        // Drag & drop
        window.addEventListener('dragover', (e) => { e.preventDefault(); });
        window.addEventListener('drop', (e) => {
            e.preventDefault();
            const file = e.dataTransfer?.files?.[0];
            if (file) {
                let url = URL.createObjectURL(file);
                url += `#name=${encodeURIComponent(file.name)}`;
                loadModelFromUrl(url, { name: file.name, mime: file.type }).catch((e) => alert('Error cargando modelo: ' + e.message));
            }
        });

        // Botón reset cámara
        document.getElementById('reset').addEventListener('click', () => {
            const obj = scene.getObjectByName('__MODEL__');
            if (obj) frameObject(obj); else { camera.position.set(2.5, 1.5, 3.5); controls.target.set(0, 0.8, 0); }
            controls.update();
        });

        // Animación
        function tick() { controls.update(); renderer.render(scene, camera); requestAnimationFrame(tick); }
        tick();

        // Resize
        window.addEventListener('resize', () => {
            const h = innerHeight - 52; // header
            camera.aspect = innerWidth / h; camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, h);
        });

        // Opcional: precargar un modelo si lo subes a tu servidor
        // loadModelFromUrl('./models/scene.glb', { name: 'scene.glb' }).catch(()=>{});
    </script>
</body>

</html>